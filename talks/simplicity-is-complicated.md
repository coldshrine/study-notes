# [Simplicity is Complicated](https://www.youtube.com/watch?v=rFejpH_tAHM)


## Success

What makes Go successful?

* Speed of compilation
* Speed of execution
* Deployment
* Tools
* Libraries

Which are not language features, these are superficial reasons. All are important but not really the answer.

## Simplicity

Go is simple, at least compared to established languages. Simplicity has many facets. Simplicity is complicated.

## Convergence

Java, JavaScript, TypeScript, C#, C++, PHP actively borrow features from one another, they are converging into a single huge language.

## Language relativity

_Sapir-Whorf hypothesis_: Language influences thought.

Controversial with regard to human languages.

Close to a fact for computer languages. Consider:

* Logic programming
* Procedural programming
* Functional programming
* Object-oriented programming
* Concurrent programming

Like disciplines in mathematics. Like, you don't solve Calculus with Algebra even though they share semantics.

## Convergence and relativity

If the languages all converge, we will all think the same.

But different ways of thinking are good.

Need different languages for different problems.

We don't want just one tool, we want a set of tools, each best at one task.

## Convergence and features

Language evolve and compete by adding features.

The languages grow in complexity while becoming more similar.

Bloat without distinction.

## Features in Go

Go is different.

Go does not try to be like the other languages.

Go does not compete on features.

As of Go 1, the language is fixed.

Many newcomers to Go ask for features from other languages they know. But those features do not belong in Go, and the language is fixed.

Adding features to Go would not make it better, just bigger.

That would make Go less interesting by being less different.

## But you need features!

Of course, there must be _some_ features.

But which ones? The right ones!

Design by consensus.

## Readability

If a language has too many features, you waste time choosing which one to use. Then implement, refine, possibly rethink and redo.

Later, "Why does the code work this way?"

_The code is harder to understand simply because it is using a more complex language._

Preferable to have just one way, or at least fewer, simpler ways.

Features add complexity. We want simplicity.

Features hurt readability. We want readability.

Readability is paramount.